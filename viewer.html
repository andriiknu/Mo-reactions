<!doctype html><meta charset="utf-8">
<title>Interactive Cross-Sections</title>


<style>
  body{ margin:0; background:#fafafa; font:14px system-ui,Segoe UI,Roboto; }
  .wrap{ max-width:1140px; margin:24px auto 32px; padding:0 16px;}
  h1{ font-weight:600; font-size:22px; margin:0 0 8px; }
  .sub{ color:#555; font-size:13px; margin:0 0 16px; }
  #chart{ height:640px; background:#fff; border:1px solid #eee; border-radius:8px; }
  #meta{ white-space:pre-wrap; font:12px/1.4 system-ui; color:#444; background:#fff;
         border:1px solid #eee; border-radius:8px; padding:10px; margin-top:12px;}
  #renormBadge{ font:11px system-ui; color:#666; background:#ffe6e6; border:1px solid #ffcccc; border-radius:4px; padding:6px 8px; margin-top:8px; display:none; }
  #renormBadge strong{ color:#c00; }
  #settingsPanel{ display:none; background:#fff; border:1px solid #eee; border-radius:8px;
                  margin:12px 16px 0; padding:12px; font:13px system-ui; gap:12px; flex-wrap:wrap; }
  #settingsPanel.active{ display:flex; }
  #settingsPanel label{ display:flex; flex-direction:column; font-size:12px; color:#555; gap:4px; min-width:160px; }
  #settingsPanel input{ padding:4px 6px; border:1px solid #ccc; border-radius:4px; font:13px system-ui; }
  #settingsPanel .settings-actions{ display:flex; gap:8px; align-items:center; }
</style>

<div class="wrap">
  <h1 id="pageTitle"></h1>
  <div id="toolbar" style="font:13px system-ui;margin:6px 16px 0;display:flex;gap:12px;align-items:center;flex-wrap:wrap">
    <span>Axis:</span>
    <label><input id="xlog" type="checkbox">x:log</label>
    <label><input id="ylog" type="checkbox">y:log</label>
    <label><input id="grid" type="checkbox" checked>grid</label>

    <span>Range x:</span>
    <input id="xmin" type="number" step="any" style="width:88px">
    <input id="xmax" type="number" step="any" style="width:88px">
    <span>y:</span>
    <input id="ymin" type="number" step="any" style="width:88px">
    <input id="ymax" type="number" step="any" style="width:88px">

    <span>Size:</span>
    <input id="w" type="number" placeholder="width" style="width:78px">
    <input id="h" type="number" placeholder="height" style="width:78px">

    <button id="apply">Repaint</button>
    <button id="csv">csv</button>
    <button id="settingsBtn" type="button">Settings</button>

    <span>Legend:</span>
    <label><input id="legend" type="checkbox" checked>on</label>
  </div>

  <div id="settingsPanel">
    <label>
      Plot title
      <input id="settingTitleText" type="text" placeholder="No title">
    </label>
    <label>
      Marker size
      <input id="settingMarkerSize" type="number" min="1" step="1" placeholder="15">
    </label>
    <label>
      Font size
      <input id="settingFontSize" type="number" min="8" step="1" placeholder="22">
    </label>
    <label>
      Font family
      <input id="settingFontFamily" type="text" placeholder="e.g. Segoe UI">
    </label>
    <label>
      X Label Font Size
      <input id="settingXFontSize" type="number" min="8" step="1" placeholder="Auto">
    </label>
    <label>
      X Label Font Family
      <input id="settingXFontFamily" type="text" placeholder="Auto">
    </label>
    <label>
      Y Label Font Size
      <input id="settingYFontSize" type="number" min="8" step="1" placeholder="Auto">
    </label>
    <label>
      Y Label Font Family
      <input id="settingYFontFamily" type="text" placeholder="Auto">
    </label>
    <label>
      Canvas width
      <input id="settingCanvasWidth" type="number" min="300" step="20" placeholder="Auto">
    </label>
    <label>
      Y label offset
      <input id="settingYLabelPadding" type="number" min="0" step="2" placeholder="8">
    </label>
    <label>
      X label offset
      <input id="settingXLabelPadding" type="number" min="0" step="2" placeholder="Auto">
    </label>
    <label>
      Image DPI scale
      <input id="settingDpiScale" type="number" min="1" step="0.5" placeholder="2">
    </label>
    <div class="settings-actions">
      <button id="settingsApply" type="button">Apply</button>
      <button id="settingsReset" type="button">Reset</button>
    </div>
  </div>
  <div id="chart"></div>
  <div id="renormBadge"></div>
  <pre id="meta"></pre>
</div>

<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
<script src="lib/parser.js"></script>
<script>
(function(){
  const embedded = document.getElementById('x4json');
  const metaEl = document.getElementById('meta');

  // load renormalization map (optional)
  let renormMap = {};
  function loadRenorm(){
    return fetch('data/renorm.json', { cache: 'no-store' })
      .then(r => r.ok ? r.json() : {})
      .then(j => { renormMap = j || {}; return renormMap; })
      .catch(()=>{ renormMap = {}; return renormMap; });
  }

  // load viewer config (yaml-like)
  function loadConfig(){
    return fetch('viewer_config.yaml', { cache: 'no-store' })
      .then(r => r.ok ? r.text() : '')
      .then(text => {
        const c = {};
        if(!text) return c;
        text.split('\n').forEach(line => {
          const t = line.trim();
          if(!t || t.startsWith('#')) return;
          const separatorIndex = t.indexOf(':');
          if (separatorIndex > 0) {
             const k = t.substring(0, separatorIndex).trim();
             const v_str = t.substring(separatorIndex + 1).trim();
             const v_num = parseFloat(v_str);

             if (String(v_num) === v_str) { // It's a number
                 c[k] = v_num;
             } else { // It's a string, remove quotes
                 c[k] = v_str.replace(/^['"]|['"]$/g, '');
             }
          }
        });
        return c;
      })
      .catch(() => ({}));
  }

  // --- TXT helpers ---
  function normalizeUnitToken(unit){
    return String(unit || '').trim().toLowerCase().replace(/[^a-z]/g, '');
  }

  function unitToMeV(unit){
    switch(normalizeUnitToken(unit)){
      case 'ev': return 1e-6;
      case 'kev': return 1e-3;
      case 'mev': return 1;
      case 'gev': return 1e3;
      case 'tev': return 1e6;
      default: return 1;
    }
  }

  function unitToBarn(unit){
    switch(normalizeUnitToken(unit)){
      case 'b':
      case 'barn':
        return 1;
      case 'kb':
        return 1e3;
      case 'mb':
        return 1e-3;
      case 'ub':
      case 'microb':
      case 'microbarn':
        return 1e-6;
      case 'nb':
        return 1e-9;
      case 'pb':
        return 1e-12;
      default:
        return 1;
    }
  }

  function parseNumericToken(token){
    if (token === null || token === undefined) return NaN;
    const normalized = String(token).trim().replace(',', '.');
    if (!normalized) return NaN;
    const num = Number(normalized);
    return Number.isFinite(num) ? num : NaN;
  }

  function parseTxtDataset(text, opts={}){
    if (!text || !text.trim()) throw new Error('TXT file is empty');
    const rawLines = text.split(/\r?\n/);
    const nonEmpty = rawLines.map(l => l.trim()).filter(Boolean);
    if (!nonEmpty.length) throw new Error('TXT file has no content');

    const titleGuess = nonEmpty[0];
    let headerIdx = rawLines.findIndex(line => /\bENERGY\b/i.test(line));
    let unitIdx = -1;
    if (headerIdx >= 0){
      for (let i = headerIdx + 1; i < rawLines.length; i++){
        if (rawLines[i] && rawLines[i].trim()){
          unitIdx = i;
          break;
        }
      }
    }
    if (unitIdx < 0){
      unitIdx = rawLines.findIndex(line => /\bMEV\b/i.test(line));
    }

    const headerTokens = headerIdx >= 0 ? rawLines[headerIdx].trim().split(/\s+/) : [];
    const unitTokens = unitIdx >= 0 ? rawLines[unitIdx].trim().split(/\s+/) : [];
    const energyUnit = unitTokens[0] || 'MeV';
    const sigmaUnit = unitTokens[1] || 'barn';
    const traceLabel = headerTokens[1] || 'Column 2';

    const dataStart = unitIdx >= 0 ? unitIdx + 1 : (headerIdx >= 0 ? headerIdx + 1 : 0);
    const xs = [], ys = [], errs = [];
    for (let i = dataStart; i < rawLines.length; i++){
      const line = rawLines[i];
      if (!line) continue;
      const trimmed = line.trim();
      if (!trimmed || /^[A-Za-z#]/.test(trimmed)) continue;
      const parts = trimmed.split(/\s+/);
      if (parts.length < 2) continue;
      const energy = parseNumericToken(parts[0]);
      const sigma = parseNumericToken(parts[1]);
      if (!Number.isFinite(energy) || !Number.isFinite(sigma)) continue;
      xs.push(energy);
      ys.push(sigma);
      errs.push(parts.length > 2 ? parseNumericToken(parts[2]) : NaN);
    }

    if (!xs.length) throw new Error('TXT parser did not detect numeric rows');

    const energyFactor = unitToMeV(energyUnit);
    const sigmaFactor = unitToBarn(sigmaUnit);
    const xMeV = xs.map(val => val * energyFactor);
    const yBarn = ys.map(val => val * sigmaFactor);
    const yErrBarn = errs.map(val => Number.isFinite(val) ? val * sigmaFactor : NaN);
    const hasErrors = yErrBarn.some(val => Number.isFinite(val));

    const displayName = opts.traceName || `${traceLabel} (TXT)`;
    const trace = {
      x: xMeV,
      y: yBarn,
      mode: 'lines+markers',
      name: displayName,
      line: { color: '#1f77b4', width: 2 },
      marker: { size: 6, color: '#1f77b4' },
      hovertemplate: '<b>'+displayName+'</b><br>E = %{x:.3f} MeV<br>œÉ = %{y:.5f} b<extra></extra>'
    };
    if (hasErrors){
      trace.error_y = {
        type: 'data',
        array: yErrBarn,
        visible: true,
        thickness: 1,
        width: 2,
        color: 'rgba(0,0,0,.35)'
      };
    }

    const meta = [];
    const sourceId = opts.sourceId ? `Source: ${opts.sourceId}` : 'Source: TXT file';
    meta.push(`${sourceId} ‚Äî using first two columns`);
    meta.push(`Energy unit: ${energyUnit} ‚Üí MeV, cross-section unit: ${sigmaUnit} ‚Üí barn`);
    meta.push(`Points parsed: ${xMeV.length}`);
    if (hasErrors) meta.push('Uncertainties detected in 3rd column and plotted as error bars');

    return {
      traces: [trace],
      title: opts.title || titleGuess || 'TXT dataset',
      meta
    };
  }
  
  
   // –ì–ª–æ–±–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω (–≤ –º–µ–∂–∞—Ö —Ü—å–æ–≥–æ –∑–∞–º–∏–∫–∞–Ω–Ω—è)
   const defaultSettings = {
     markerSize:15,
     fontSize:22,
     fontFamily:'',
     fontColor: '',
     canvasWidth:null,
     yLabelPadding:8,
     xLabelPadding:null,
     titleText:'',
     xFontSize:null,
     xFontFamily:'',
     yFontSize:null,
     yFontFamily:'',
     dpiScale: 2
   };
   const appState = {
     traces: [],
     originalTitle: '',
     meta: [],
     settings: { ...defaultSettings }
   };
  
   // Debug: –ª–æ–≥—É—î–º–æ –Ω–∞ —Å—Ç–æ—Ä—ñ–Ω–∫—É
   function dbgLog(msg) {
     console.log(msg);
     if (!metaEl) return;
     const line = document.createElement('div');
     line.style.cssText = 'font-size:11px;color:#666;font-family:monospace;margin:4px 0';
     line.textContent = msg;
     metaEl.appendChild(line);
   }
  
  function toggleLegendGroup(gd, groupName){
    if (!gd || !groupName) return;
    const traces = gd.data || [];
    const indices = [];
    for (let i=0;i<traces.length;i++){
      if (traces[i].legendgroup === groupName) indices.push(i);
    }
    if (!indices.length) return;
    const anyVisible = indices.some(idx => traces[idx].visible !== 'legendonly');
    const target = anyVisible ? 'legendonly' : true;
    Plotly.restyle(gd, { visible: target }, indices);
  }

  function setupLegendGroupToggle(gd){
    if (!gd) return;
    if (!gd.__legendGroupHandler){
      gd.on('plotly_legendgroupclick', evt => {
        const groupName = evt?.legendgroup || evt?.group || evt?.data?.[evt.curveNumber]?.legendgroup || '';
        if (!groupName) return;
        toggleLegendGroup(gd, groupName);
        return false;
      });
      gd.__legendGroupHandler = true;
    }
    requestAnimationFrame(()=>{
      const titles = document.querySelectorAll('#chart .legendgrouptitle');
      const groups = [];
      (gd.data||[]).forEach(tr => {
        const g = tr.legendgroup;
        if (g && !groups.includes(g)) groups.push(g);
      });
      titles.forEach((el, idx)=>{
        if (el.__legendGroupClick) {
          el.removeEventListener('click', el.__legendGroupClick);
          el.__legendGroupClick = null;
        }
        const groupName = groups[idx];
        if (!groupName){
          el.style.pointerEvents = '';
          el.style.cursor = '';
          return;
        }
        const handler = evt => {
          evt.preventDefault();
          evt.stopPropagation();
          toggleLegendGroup(gd, groupName);
        };
        el.style.pointerEvents = 'auto';
        el.style.cursor = 'pointer';
        el.__legendGroupClick = handler;
        el.addEventListener('click', handler);
      });
    });
  }

  // --- –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è Plotly ---
  function applyFontSettingsToLayout(layout){
    if (!layout) return layout;
    const s = appState.settings || {};
    const globalFont = {};
    if (s.fontFamily) globalFont.family = s.fontFamily;
    if (s.fontColor) globalFont.color = s.fontColor;
    if (typeof s.fontSize === 'number' && !Number.isNaN(s.fontSize)) globalFont.size = s.fontSize;

    layout.title.font = { ...(layout.title?.font || {}), ...globalFont };
    layout.legend.font = { ...(layout.legend?.font || {}), ...globalFont };

    ['xaxis','yaxis'].forEach(axis => {
      layout[axis] = layout[axis] || {};
      layout[axis].title = layout[axis].title || {};
      layout[axis].tickfont = { ...(layout[axis].tickfont || {}), ...globalFont };

      const specificSize = axis === 'xaxis' ? s.xFontSize : s.yFontSize;
      const specificFamily = axis === 'xaxis' ? s.xFontFamily : s.yFontFamily;
      const axisFont = { ...globalFont };
      if (specificFamily) axisFont.family = specificFamily;
      if (typeof specificSize === 'number' && !Number.isNaN(specificSize)) axisFont.size = specificSize;

      layout[axis].title.font = { ...(layout[axis].title.font || {}), ...axisFont };
    });
    return layout;
  }

  function getEffectiveFontSize(axis){
    const s = appState.settings || {};
    let size = s.fontSize;
    if (axis === 'x' && typeof s.xFontSize === 'number') size = s.xFontSize;
    if (axis === 'y' && typeof s.yFontSize === 'number') size = s.yFontSize;
    return (typeof size === 'number' && Number.isFinite(size) && size > 0) ? size : 18;
  }

  function getTitleText(){
    const title = appState.settings?.titleText;
    return (typeof title === 'string') ? title : '';
  }

  function computeAutoYLabelPadding(){
    const fontSize = getEffectiveFontSize('y');
    return 10 + Math.max(0, (fontSize - 18) * 2);
  }

  function getYLabelPadding(){
    const setting = appState.settings?.yLabelPadding;
    if (typeof setting === 'number' && setting >= 0 && Number.isFinite(setting)) return setting;
    return computeAutoYLabelPadding();
  }

  function computeAutoLeftMargin(){
    const fontSize = getEffectiveFontSize();
    const yPad = getYLabelPadding();
    const extra = Math.max(0, (fontSize - 18) * 5);
    return 70 + extra + Math.min(yPad, 40);
  }

  function computeAutoXLabelPadding(){
    const fontSize = getEffectiveFontSize('x');
    return 10 + Math.max(0, (fontSize - 18) * 1.5);
  }

  function getXLabelPadding(){
    const setting = appState.settings?.xLabelPadding;
    if (typeof setting === 'number' && setting >= 0 && Number.isFinite(setting)) return setting;
    return computeAutoXLabelPadding();
  }

  function computeAutoBottomMargin(){
    const fontSize = getEffectiveFontSize();
    const xPad = getXLabelPadding();
    const extra = Math.max(0, (fontSize - 18) * 4);
    return 70 + extra + Math.min(xPad, 40);
  }

  function enforceLogTickConsistency(axis){
    if (!axis) return;
    if (axis.type === 'log'){
      axis.dtick = 1;
      axis.tick0 = 0;
      axis.minor = axis.minor || {};
      axis.minor.ticks = axis.minor.ticks || 'outside';
      axis.minor.showgrid = axis.minor.showgrid ?? false;
    }else{
      if (axis.dtick === 1) delete axis.dtick;
      if (axis.tick0 === 0) delete axis.tick0;
    }
  }

  function updateLegendPresence(layout, showLegend){
    if (!layout) return layout;
    layout.legend = layout.legend || {};
    layout.margin = layout.margin || {};
    if (showLegend){
      layout.margin.r = Math.max(layout.margin.r ?? 0, 140);
      layout.legend.x = 1.02;
      layout.legend.y = 1;
    }else{
      layout.legend.x = 1;
      layout.margin.r = 40;
    }
    layout.showlegend = showLegend;
    return layout;
  }

  function layoutEXFOR(){
    const layout = {
       title: { text: getTitleText(), x:0.02, xanchor:'left', font:{size:18, weight:600} },
      template: 'plotly_white',
      hovermode: 'closest',
      legend: {
        x:1.02, y:1, xanchor:'left', yanchor:'top',
        bgcolor:'rgba(255,255,255,.8)', bordercolor:'#eee', borderwidth:1,
        groupclick:'toggleitem'
      },
      margin: { l:70, r:140, t:60, b:70 },
      xaxis: {
        title: { text:'Incident Energy (MeV)' },
        showgrid:true, gridcolor:'#eee', zeroline:false, ticks:'outside'
      },
      yaxis: {
        title: { text:'Cross section (barns)' },
        showgrid:true, gridcolor:'#eee', zeroline:false, ticks:'outside'
      },
      updatemenus: [{
        type:'buttons', x:0.02, y:1.13, xanchor:'left', yanchor:'top',
        pad:{r:8, t:0}, direction:'right',
      }]
    };
    const yLabelPadding = getYLabelPadding();
    const xLabelPadding = getXLabelPadding();
    layout.yaxis.title = layout.yaxis.title || {};
    layout.yaxis.title.standoff = yLabelPadding;
    layout.xaxis.title = layout.xaxis.title || {};
    layout.xaxis.title.standoff = xLabelPadding;
    layout.margin.l = Math.max(layout.margin.l, computeAutoLeftMargin());
    layout.margin.b = Math.max(layout.margin.b, computeAutoBottomMargin());
    const canvasWidth = appState.settings?.canvasWidth;
    if (!layout.width && typeof canvasWidth === 'number' && canvasWidth > 0) {
      layout.width = canvasWidth;
    }
    const initialLegendState = document.getElementById('legend')?.checked ?? true;
    updateLegendPresence(layout, initialLegendState);
    return applyFontSettingsToLayout(layout);
  }

  function copyPlotToClipboard(gd){
    const graphDiv = gd && gd.nodeType ? gd : document.getElementById('chart');
    if (!graphDiv){
      dbgLog('‚úó copyPlotToClipboard: graph div not found');
      return;
    }
    if (!navigator.clipboard || typeof ClipboardItem === 'undefined'){
      alert('Clipboard copy is not supported in this browser');
      return;
    }
    const exportOpts = { format:'png', scale: appState.settings.dpiScale || 2 };
    const layout = graphDiv._fullLayout;
    if (layout){
      exportOpts.width = layout.width;
      exportOpts.height = layout.height;
    }
    Plotly.toImage(graphDiv, exportOpts)
      .then(dataUrl => fetch(dataUrl))
      .then(res => res.blob())
      .then(blob => navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]))
      .then(() => dbgLog('üìã Plot copied to clipboard'))
      .catch(err => {
        console.error('copyPlotToClipboard error:', err);
        alert('Failed to copy plot: ' + (err && err.message ? err.message : err));
      });
  }

  function applyStyleOverrides(traces){
    const { markerSize } = appState.settings || {};
    const numericMarkerSize = (typeof markerSize === 'number' && markerSize > 0) ? markerSize : null;
    if (!numericMarkerSize) return traces;
    return (traces || []).map(tr => {
      if (!tr) return tr;
      const usesMarkers = typeof tr.mode === 'string' && tr.mode.includes('markers');
      const hasMarkerObj = tr.marker && typeof tr.marker === 'object';
      if (!usesMarkers && !hasMarkerObj) return tr;
      const copy = { ...tr };
      copy.marker = { ...(tr.marker || {}) };
      copy.marker.size = numericMarkerSize;
      return copy;
    });
  }

  function configEXFOR(){
    const userDefinedFilename = getTitleText();
    const defaultFilename = appState.originalTitle;

    const rawFilename = userDefinedFilename || defaultFilename || 'plot';
    const cleanFilename = rawFilename.replace(/<[^>]*>/g, ''); // Strip HTML tags

    // Remove the observable part, like "‚Äî SIG"
    const coreFilename = cleanFilename.split(' ‚Äî ')[0];

    const filename = coreFilename
      .replace(/[^a-z0-9_ -]/gi, '_').replace(/ /g, '_');

    return {
      responsive:true,
      displaylogo:false,
      toImageButtonOptions: {
        filename: filename,
        scale: appState.settings.dpiScale || 2
      },
      modeBarButtonsToRemove:[
        'select2d','lasso2d','zoomIn2d','zoomOut2d','autoScale2d',
       'toggleSpikelines','hoverClosestCartesian','hoverCompareCartesian'
      ],
      modeBarButtonsToAdd: [{
        name:'Copy to clipboard',
        title:'Copy plot PNG to clipboard',
        icon:Plotly.Icons.camera,
        click:gd => copyPlotToClipboard(gd)
      }]
    };
  }

   // --- –ì–æ–ª–æ–≤–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –ø–µ—Ä–µ–º–∞–ª—å–æ–≤–∫–∏ ---
   function repaintChart() {
     dbgLog('üñåÔ∏è Repaint triggered');
  
     // –Ø–∫—â–æ –¥–∞–Ω–∏—Ö –Ω–µ–º–∞—î, –ø—Ä–æ–±—É—î–º–æ –≤–∑—è—Ç–∏ –ø–æ—Ç–æ—á–Ω—ñ –∑ –≥—Ä–∞—Ñ—ñ–∫–∞ (fallback)
     const gd = document.getElementById('chart');
     const tracesToUse = (appState.traces && appState.traces.length > 0) 
                         ? appState.traces 
                         : (gd && gd.data ? gd.data : []);
  
     if (!tracesToUse || tracesToUse.length === 0) {
       dbgLog('‚ö†Ô∏è No traces to plot');
       return;
     }
  
     const layout = layoutEXFOR();
  
     // 1. –û—Å—ñ (Log/Linear)
     layout.xaxis.type = document.getElementById('xlog').checked ? 'log' : 'linear';
     layout.yaxis.type = document.getElementById('ylog').checked ? 'log' : 'linear';
    enforceLogTickConsistency(layout.xaxis);
    enforceLogTickConsistency(layout.yaxis);
  
     // 2. –°—ñ—Ç–∫–∞
     const grid = document.getElementById('grid').checked;
     layout.xaxis.showgrid = grid; 
     layout.yaxis.showgrid = grid;
  
     // 3. –î—ñ–∞–ø–∞–∑–æ–Ω–∏ (–∑ –ø–µ—Ä–µ–≤—ñ—Ä–∫–æ—é –Ω–∞ –≤–∞–ª—ñ–¥–Ω–µ —á–∏—Å–ª–æ)
     const getVal = (id) => {
       const v = document.getElementById(id).value.trim();
       return (v !== '' && !isNaN(Number(v))) ? Number(v) : null;
     };
  
     const xmin = getVal('xmin'), xmax = getVal('xmax');
     if (xmin !== null || xmax !== null) layout.xaxis.range = [xmin, xmax];
  
     const ymin = getVal('ymin'), ymax = getVal('ymax');
     if (ymin !== null || ymax !== null) layout.yaxis.range = [ymin, ymax];
  
     // 4. –†–æ–∑–º—ñ—Ä–∏
     const w = getVal('w'), h = getVal('h');
     if (w) layout.width = w;
     if (h) layout.height = h;
  
     // 5. –õ–µ–≥–µ–Ω–¥–∞
     const showLegend = document.getElementById('legend').checked;
     updateLegendPresence(layout, showLegend);
  
     // –í–∏–∫–æ–Ω—É—î–º–æ —Ä–µ–∞–∫—Ç–∏–≤–Ω–µ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è (—à–≤–∏–¥—à–µ –∑–∞ newPlot)
     Plotly.react('chart', applyStyleOverrides(tracesToUse), layout, configEXFOR())
       .then(setupLegendGroupToggle)
       .catch(e => {
         dbgLog('‚ùå Plotly error: ' + e.message);
         console.error('Plotly error:', e);
       });
   }
  
   // --- Display renormalization badge ---
   function showRenormBadge(renormApplied){
     const badge = document.getElementById('renormBadge');
     if (!badge) return;
     if (!renormApplied || renormApplied.length === 0){
       badge.style.display = 'none';
       return;
     }
     const items = renormApplied.map(r => `${r.entry} √ó${r.factor}`).join(', ');
     badge.innerHTML = `<strong>Renormalized:</strong> ${items}`;
     badge.style.display = 'block';
   }
  
   // --- –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–∞–Ω–∏—Ö ---
   function initData(traces, title, meta, renormApplied) {
     // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ —Å—Ç–∞–Ω
     appState.traces = traces;
     appState.originalTitle = title;
     appState.meta = meta;
  
     // –û–Ω–æ–≤–ª—é—î–º–æ DOM
     document.getElementById('pageTitle').innerHTML = title || '';
     if(metaEl) metaEl.textContent = meta?.length ? 'Datasets included:\n' + meta.join('\n') : '';
     showRenormBadge(renormApplied);
     if (titleTextInput){
       titleTextInput.placeholder = title || 'No title';
     }
  
     // –ü–µ—Ä—à–µ –º–∞–ª—é–≤–∞–Ω–Ω—è
     Plotly.newPlot('chart', applyStyleOverrides(traces), layoutEXFOR(), configEXFOR()).then(setupLegendGroupToggle);
     dbgLog('‚úÖ Chart initialized with ' + traces.length + ' traces');
   }
  
   // --- –ü—Ä–∏–≤'—è–∑–∫–∞ –ø–æ–¥—ñ–π ---
  document.getElementById('apply').addEventListener('click', repaintChart);
  const legendToggle = document.getElementById('legend');
  if (legendToggle) legendToggle.addEventListener('change', repaintChart);
   
   const btnCsv = document.getElementById('csv');
   if(btnCsv) {
       btnCsv.addEventListener('click', () => {
           dbgLog('üìä CSV export clicked (not yet implemented)');
           alert('CSV export logic needs to be implemented');
       });
   }

  const settingsBtn = document.getElementById('settingsBtn');
  const settingsPanel = document.getElementById('settingsPanel');
  const titleTextInput = document.getElementById('settingTitleText');
  const markerSizeInput = document.getElementById('settingMarkerSize');
  const fontSizeInput = document.getElementById('settingFontSize');
  const fontFamilyInput = document.getElementById('settingFontFamily');
  const xFontSizeInput = document.getElementById('settingXFontSize');
  const xFontFamilyInput = document.getElementById('settingXFontFamily');
  const yFontSizeInput = document.getElementById('settingYFontSize');
  const yFontFamilyInput = document.getElementById('settingYFontFamily');
  const canvasWidthInput = document.getElementById('settingCanvasWidth');
  const yLabelPaddingInput = document.getElementById('settingYLabelPadding');
  const xLabelPaddingInput = document.getElementById('settingXLabelPadding');
  const dpiScaleInput = document.getElementById('settingDpiScale');
  const settingsApplyBtn = document.getElementById('settingsApply');
  const settingsResetBtn = document.getElementById('settingsReset');

  function normalizeNumberInput(value){
    if (value === null || value === undefined) return null;
    const trimmed = String(value).trim();
    if (trimmed === '') return null;
    const num = Number(trimmed);
    return Number.isFinite(num) ? num : null;
  }

  function normalizePositiveNumberInput(value, min = 0){
    const num = normalizeNumberInput(value);
    if (num === null) return null;
    return num > min ? num : null;
  }

  function syncSettingsInputs(){
    if (titleTextInput) titleTextInput.value = appState.settings.titleText || '';
    if (markerSizeInput) markerSizeInput.value = appState.settings.markerSize ?? '';
    if (fontSizeInput) fontSizeInput.value = appState.settings.fontSize ?? '';
    if (fontFamilyInput) fontFamilyInput.value = appState.settings.fontFamily || '';
    if (xFontSizeInput) xFontSizeInput.value = appState.settings.xFontSize ?? '';
    if (xFontFamilyInput) xFontFamilyInput.value = appState.settings.xFontFamily || '';
    if (yFontSizeInput) yFontSizeInput.value = appState.settings.yFontSize ?? '';
    if (yFontFamilyInput) yFontFamilyInput.value = appState.settings.yFontFamily || '';
    if (canvasWidthInput) canvasWidthInput.value = appState.settings.canvasWidth ?? '';
    if (yLabelPaddingInput) yLabelPaddingInput.value = appState.settings.yLabelPadding ?? '';
    if (xLabelPaddingInput) xLabelPaddingInput.value = appState.settings.xLabelPadding ?? '';
    if (dpiScaleInput) dpiScaleInput.value = appState.settings.dpiScale ?? '';
  }

  function applySettingsFromInputs(){
    const canvasWidth = normalizePositiveNumberInput(canvasWidthInput?.value, 200);
    const yLabelPadNum = normalizeNumberInput(yLabelPaddingInput?.value);
    const yLabelPadding = (yLabelPadNum !== null && yLabelPadNum >= 0) ? yLabelPadNum : null;
    const xLabelPadNum = normalizeNumberInput(xLabelPaddingInput?.value);
    const xLabelPadding = (xLabelPadNum !== null && xLabelPadNum >= 0) ? xLabelPadNum : null;
    appState.settings = {
      titleText: (titleTextInput?.value || '').trim(),
      markerSize: normalizeNumberInput(markerSizeInput?.value),
      fontSize: normalizeNumberInput(fontSizeInput?.value),
      fontFamily: (fontFamilyInput?.value || '').trim(),
      xFontSize: normalizeNumberInput(xFontSizeInput?.value),
      xFontFamily: (xFontFamilyInput?.value || '').trim(),
      yFontSize: normalizeNumberInput(yFontSizeInput?.value),
      yFontFamily: (yFontFamilyInput?.value || '').trim(),
      canvasWidth,
      yLabelPadding,
      xLabelPadding,
      dpiScale: normalizePositiveNumberInput(dpiScaleInput?.value, 0.5)
    };
    repaintChart();
  }

  if (settingsBtn && settingsPanel){
    settingsBtn.addEventListener('click', ()=>{
      const isOpen = settingsPanel.classList.toggle('active');
      if (isOpen) syncSettingsInputs();
    });
  }

  if (settingsApplyBtn){
    settingsApplyBtn.addEventListener('click', ()=>{
      applySettingsFromInputs();
      syncSettingsInputs();
    });
  }

  if (settingsResetBtn){
    settingsResetBtn.addEventListener('click', ()=>{
      appState.settings = { ...defaultSettings };
      syncSettingsInputs();
      repaintChart();
    });
  }
  
  Promise.all([loadRenorm(), loadConfig()]).then(([_, config]) => {
    // Apply YAML config to defaults
    if(config.marker_size) defaultSettings.markerSize = config.marker_size;
    if(config.font_size) defaultSettings.fontSize = config.font_size;
    if(config.font_family) defaultSettings.fontFamily = config.font_family;
    if(config.font_color) defaultSettings.fontColor = config.font_color;
    if(config.x_label_offset) defaultSettings.xLabelPadding = config.x_label_offset;
    if(config.y_label_offset) defaultSettings.yLabelPadding = config.y_label_offset;
    if(config.dpi_scale) defaultSettings.dpiScale = config.dpi_scale;
    
    // Update current state
    appState.settings = { ...defaultSettings };
    syncSettingsInputs();

    dbgLog('üîß viewer.html script loaded, window.__renderX4 type: ' + (typeof window.__renderX4));

    // --- –õ–æ–≥—ñ–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è (Embedded vs Fetch) ---
   // 1) offline –≤–±—É–¥–æ–≤–∞–Ω–∏–π JSON
   if (embedded){
    try{
      const x4 = JSON.parse(embedded.textContent);
      if (typeof window.__renderX4 !== 'function') throw new Error('parser.js not loaded');
      const {traces, title, meta, renormApplied} = window.__renderX4(x4, {returnTraces:true, renormMap});
      initData(traces, title, meta, renormApplied);
      return;
    }catch(e){
      metaEl.textContent = 'Invalid embedded JSON: '+(e && e.message ? e.message : String(e));
      return;
    }
  }

  // 2) online –∑–∞ ?id=
  const params = new URLSearchParams(location.search);
  const id = params.get('id');
  if (!id){ metaEl.textContent = 'Add ?id=ga69_pn (expects /data/ga69_pn.json)'; return; }
  const safeId = id.trim();
  if (!/^[\w(),.\-\/]+$/.test(safeId)){
    metaEl.textContent = 'Invalid dataset id. Allowed characters: letters, digits, _, -, ., /, (, ), ,';
    return;
  }
  const fileParamRaw = params.get('file');
  const fileParam = fileParamRaw ? fileParamRaw.trim() : '';
  if (fileParam && !/^[\w(),.\-\/]+$/.test(fileParam)){
    metaEl.textContent = 'Invalid file parameter.';
    return;
  }
  const fmtParam = (params.get('fmt') || '').trim().toLowerCase();
  const requestedTitle = params.get('title') || '';
  const traceNameParam = params.get('trace') || params.get('label') || '';

  const idHasExtension = /\.[A-Za-z0-9]+$/.test(safeId);
  const defaultPath = idHasExtension ? `data/${safeId}` : `data/${safeId}.json`;
  const dataPath = fileParam ? `data/${fileParam}` : defaultPath;
  const extMatch = dataPath.match(/\.([a-z0-9]+)$/i);
  const inferredFormat = fmtParam || (extMatch ? extMatch[1].toLowerCase() : 'json');
  const isTxt = inferredFormat === 'txt';

  fetch(dataPath, { cache: 'no-store' }).then(r => {
    if(!r.ok) throw new Error('HTTP '+r.status);
    return isTxt ? r.text() : r.json();
  }).then(payload => {
    if (isTxt){
      dbgLog('‚úì TXT loaded, bytes=' + payload.length);
      const parsed = parseTxtDataset(payload, {
        title: requestedTitle || safeId,
        traceName: traceNameParam || requestedTitle || safeId,
        sourceId: fileParam || safeId
      });
      initData(parsed.traces, parsed.title, parsed.meta, []);
      dbgLog('‚úì TXT dataset parsed, traces=' + parsed.traces.length);
      return;
    }

    const x4 = payload;
    dbgLog('‚úì JSON loaded, type=' + (Array.isArray(x4) ? 'array' : 'object'));
    dbgLog('‚úì x4 keys: ' + Object.keys(x4).join(', '));
    if (x4.datasets) dbgLog('‚úì datasets.length = ' + x4.datasets.length);

    if (typeof window.__renderX4 !== 'function') {
      dbgLog('‚úó ERROR: window.__renderX4 is not a function!');
      dbgLog('‚úó Type: ' + typeof window.__renderX4);
      throw new Error('window.__renderX4 is not a function');
    }

    dbgLog('üî® Calling __renderX4...');
    const {traces, title, meta, renormApplied} = window.__renderX4(x4, {returnTraces:true, renormMap});
    dbgLog('‚úì __renderX4 returned: traces=' + traces.length + ', title_len=' + (title ? title.length : 0));

    initData(traces, title, meta, renormApplied);
    dbgLog('‚úì Chart initialized via initData');
  }).catch(err => {
    console.error('Error:', err);
    const msg = 'Failed to load '+dataPath+': '+(err && err.message ? err.message : String(err));
    dbgLog('‚úó ' + msg);
    metaEl.textContent = msg;
  });
  });
})();
</script>
